# 第一章：帧同步基础概念

## 1.1 什么是帧同步？

帧同步（Frame Synchronization / Lockstep）是一种多人游戏同步技术，其核心思想是：

> **所有客户端在相同的逻辑帧上执行相同的输入，从而得到相同的游戏状态。**

### 与状态同步的对比

| 特性 | 帧同步 | 状态同步 |
|------|--------|----------|
| 同步内容 | 只同步输入 | 同步完整游戏状态 |
| 带宽消耗 | 低（仅输入数据） | 高（大量状态数据） |
| 服务端压力 | 低（只转发） | 高（计算状态） |
| 作弊防范 | 较难（需要验证） | 较易（服务端权威） |
| 断线重连 | 复杂（需要重放） | 简单（直接下发状态） |
| 典型应用 | RTS（星际、WAR3）、格斗游戏 | FPS（CS、OW）、MMO |

## 1.2 帧同步的工作流程

```
┌─────────────────────────────────────────────────────────────┐
│                        帧同步流程                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  客户端 A              服务端              客户端 B          │
│     │                   │                    │              │
│     │─── 输入 A ────────▶│                    │              │
│     │                   │◀─── 输入 B ─────────│              │
│     │                   │                    │              │
│     │      收集所有玩家该帧的输入              │              │
│     │                   │                    │              │
│     │◀── 帧输入 [A,B] ──│─── 帧输入 [A,B] ───▶│              │
│     │                   │                    │              │
│     │    执行相同的逻辑帧更新                  │              │
│     │    （确定性物理 + 相同输入）             │              │
│     │                   │                    │              │
│     │◀─────── 状态一致 ──────────────────────▶│              │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 核心步骤

1. **输入收集**：客户端每帧采集玩家输入（键盘、鼠标等）
2. **输入上传**：将输入发送给服务端
3. **帧打包**：服务端等待所有玩家输入，打包成一帧
4. **帧分发**：服务端将完整帧输入广播给所有客户端
5. **逻辑执行**：所有客户端用相同输入执行相同的游戏逻辑
6. **状态一致**：由于输入和逻辑相同，最终状态一致

## 1.3 关键概念

### 1.3.1 逻辑帧 vs 渲染帧

```python
# 逻辑帧：固定频率（如 30fps），负责游戏逻辑
LOGIC_FPS = 30
LOGIC_FRAME_TIME = 1000 // LOGIC_FPS  # 约 33ms

# 渲染帧：可变频率（如 60fps），负责画面渲染
# 渲染帧不参与同步，只负责展示

def game_loop():
    """游戏主循环"""
    logic_accumulator = 0
    
    while running:
        frame_start = current_time()
        delta_time = frame_start - last_frame_time
        last_frame_time = frame_start
        
        logic_accumulator += delta_time
        
        # 固定步长的逻辑更新
        while logic_accumulator >= LOGIC_FRAME_TIME:
            update_logic_frame()  # 确定性逻辑
            logic_accumulator -= LOGIC_FRAME_TIME
        
        # 可变步长的渲染
        interpolation = logic_accumulator / LOGIC_FRAME_TIME
        render_frame(interpolation)  # 渲染与同步无关
```

**为什么分离？**
- 逻辑帧必须固定步长，保证确定性
- 渲染帧可灵活适应不同硬件性能
- 插值渲染让画面更平滑

### 1.3.2 帧缓冲（Frame Buffer）

```
时间轴：
├─────┼─────┼─────┼─────┼─────┼─────┤
│     │     │     │     │     │     │
F-2   F-1   F0    F+1   F+2   F+3

      └─── 帧缓冲区 ───┘
       [F-2, F-1, F0]
       
当前帧：F0
已确认帧：F-2, F-1（收到所有玩家输入）
预测帧：F0（还在等待输入）
```

**帧缓冲的作用**：
- 抵消网络延迟
- 平滑网络抖动
- 典型设置：2-4 帧缓冲

### 1.3.3 确定性（Determinism）

> **相同输入 + 相同初始状态 = 相同最终状态**

这是帧同步的根本前提，但实现起来有很多坑：

```python
# ❌ 非确定性：浮点数精度问题
def bad_physics(obj, dt):
    obj.x += obj.vx * dt  # 不同机器可能有细微差异

# ✅ 确定性：定点数或整数运算
def good_physics(obj, dt_fixed):
    # dt_fixed 是固定整数，如 33（毫秒）
    obj.x += obj.vx * dt_fixed  # 整数运算，完全确定
```

## 1.4 帧同步的优缺点

### 优点

1. **带宽友好**：只传输输入（几个字节），不传状态（可能几KB）
2. **服务端轻量**：服务端只转发，不计算，可支撑大量对局
3. **原生回放**：保存输入即可完美回放
4. **开发友好**：逻辑和服务端解耦，易于调试

### 缺点

1. **确定性要求高**：任何不确定因素都会导致同步失败
2. **延迟敏感**：所有玩家必须等待最慢的那个
3. **作弊风险**：客户端掌握完整逻辑
4. **重连复杂**：需要从开始重放所有帧

## 1.5 适用场景

**适合帧同步：**
- 策略游戏（RTS）
- 格斗游戏
- 回合制游戏
- 玩家数量少（2-8人）
- 延迟要求不极端（<100ms 可接受）

**不适合帧同步：**
- 大规模 MMO
- 高延迟网络环境
- 需要强防作弊
- 物理模拟非常复杂

## 1.6 本章小结

- 帧同步通过同步输入而非状态实现多人游戏
- 核心是确定性：相同输入必须产生相同结果
- 逻辑帧和渲染帧分离，保证同步稳定
- 帧缓冲用于抵消网络延迟
- 适合策略、格斗等中小规模对战游戏

---

**下一章**：[确定性模拟](02-determinism.md) - 如何保证计算结果的绝对一致
