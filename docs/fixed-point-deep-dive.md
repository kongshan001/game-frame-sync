# 定点数深度解析：为什么帧同步必须用它？

> 本文档用最通俗的方式解释定点数的原理、必要性，以及误差问题

## 目录

1. [先理解问题：为什么浮点数不行？](#1-先理解问题为什么浮点数不行)
2. [定点数原理：把小数变成整数](#2-定点数原理把小数变成整数)
3. [定点数的误差：真的会有问题吗？](#3-定点数的误差真的会有问题吗)
4. [实战：定点数在帧同步中的应用](#4-实战定点数在帧同步中的应用)
5. [常见问题解答](#5-常见问题解答)

---

## 1. 先理解问题：为什么浮点数不行？

### 1.1 一个真实的崩溃场景

假设你开发了一款帧同步 MOBA 游戏，两个玩家在两台不同的设备上对战：

```
玩家A（iPhone 15 Pro）: 角色位置 (100.0, 200.0)
玩家B（Android 旗舰机）: 角色位置 (100.0, 200.0)
```

看起来一样对吧？但问题是：

```python
# 玩家A的设备执行
position = 0.1 + 0.2  # 结果可能是 0.30000000000000004

# 玩家B的设备执行  
position = 0.1 + 0.2  # 结果可能是 0.29999999999999999
```

**差异只有 0.00000000000000005，看起来微不足道？**

### 1.2 蝴蝶效应：微小差异的指数级放大

```
帧 1:    差异 0.00000000000000005（肉眼不可见）
帧 100:  差异 0.0000001（仍然不可见）
帧 1000: 差异 0.001（开始有细微偏差）
帧 5000: 差异 0.5（两个角色位置明显不同）
帧 10000: 差异 10.0（一个在塔下，一个在河道）
帧 20000: 差异 100.0（完全不同的游戏状态！）
```

**这就是"状态分叉"**：两个客户端从同一个起点出发，最终走向了完全不同的世界。

### 1.3 为什么浮点数会不一致？

#### 原因1：CPU 架构差异

```
Intel x86 (x87 FPU): 80位内部精度
Intel x86 (SSE/AVX):  32/64位精度
ARM (手机):           64位精度
```

同样的 `0.1 + 0.2`，不同 CPU 可能产生不同结果。

#### 原因2：编译器优化

```c
// 代码
float a = 0.1f;
float b = 0.2f;
float c = a + b;

// 编译器优化后可能变成
float c = 0.3f;  // 直接常量折叠，精度不同！
```

#### 原因3：运算顺序

```python
# 数学上等价，但浮点结果不同
(0.1 + 0.2) + 0.3 != 0.1 + (0.2 + 0.3)

# 实际计算
>>> (0.1 + 0.2) + 0.3
0.6000000000000001
>>> 0.1 + (0.2 + 0.3)
0.6000000000000001
# 看起来一样？换种写法：
>>> sum([0.1, 0.2, 0.3])
0.6000000000000001
>>> 0.1 + 0.2 + 0.3
0.6000000000000001
>>> (0.1*10 + 0.2*10 + 0.3*10) / 10
0.6  # 又不一样了！
```

### 1.4 帧同步的致命要求

帧同步的核心假设是：

> **相同输入 + 相同初始状态 = 相同最终状态**

浮点数打破了这个等式，因为：

> **相同输入 + 相同初始状态 + 浮点数 ≠ 相同最终状态** ❌

---

## 2. 定点数原理：把小数变成整数

### 2.1 核心思想：放大再缩小

**思路**：如果我们用整数来表示小数，那么所有设备上的整数运算结果都是一致的！

```
浮点数思路: 直接存 3.14
定点数思路: 把 3.14 放大 100 倍变成 314，存整数

要用的时候: 314 / 100 = 3.14
```

### 2.2 16.16 定点数格式

最常用的定点数格式是 **16.16**：

```
32位整数被分成两部分：

┌─────────────────┬─────────────────┐
│   整数部分 (16位)  │   小数部分 (16位)  │
│      高 16 位      │      低 16 位      │
└─────────────────┴─────────────────┘

放大倍数 = 2^16 = 65536
```

**示例**：

| 浮点数 | 定点数（内部存储） | 计算方式 |
|--------|-------------------|----------|
| 1.0 | 65536 | 1.0 × 65536 |
| 3.14 | 205768 | 3.14 × 65536 ≈ 205768.96 → 205768 |
| 100.5 | 6586368 | 100.5 × 65536 |
| -50.25 | -3293184 | -50.25 × 65536 |
| 0.5 | 32768 | 0.5 × 65536 |

### 2.3 定点数运算规则

#### 加减法（最简单）

```python
# 直接加减，和整数一样！
定点数 a = 3.0 → 内部值 196608
定点数 b = 1.5 → 内部值 98304

a + b:
  内部值 = 196608 + 98304 = 294912
  实际值 = 294912 / 65536 = 4.5 ✅
```

#### 乘法（需要调整）

```python
# 问题：两个定点数相乘，scale 会翻倍
a = 2.0 → 内部值 131072 (2.0 × 65536)
b = 3.0 → 内部值 196608 (3.0 × 65536)

错误做法:
  131072 × 196608 = 25769803776
  25769803776 / 65536 = 393216  # 这是 6.0 的 scale 平方！

正确做法（除以 scale）:
  (131072 × 196608) >> 16 = 393216
  393216 / 65536 = 6.0 ✅

代码实现:
  def fixed_mul(a, b):
      return (a * b) >> 16  # 右移16位 = 除以65536
```

#### 除法（需要调整）

```python
# 问题：两个定点数相除，scale 会消失
a = 6.0 → 内部值 393216
b = 2.0 → 内部值 131072

错误做法:
  393216 / 131072 = 3  # 这是 3.0/65536，不是 3.0！

正确做法（先乘以 scale）:
  (393216 << 16) / 131072 = 196608
  196608 / 65536 = 3.0 ✅

代码实现:
  def fixed_div(a, b):
      return (a << 16) // b  # 左移16位 = 乘以65536
```

### 2.4 为什么整数运算一定一致？

**答案**：因为整数运算的数学定义是**精确**的。

```python
# 任何设备上
>>> 131072 + 65536
196608  # 永远是这个结果，不会变

>>> 131072 * 196608
25769803776  # 永远是这个结果

>>> 25769803776 >> 16
393216  # 位运算也是精确的
```

整数运算不涉及 IEEE 754 浮点标准的复杂性，**不存在精度问题**，**不存在舍入差异**。

---

## 3. 定点数的误差：真的会有问题吗？

这是你关心的问题！让我们诚实面对。

### 3.1 定点数确实有误差

**误差来源1：浮点转定点时的截断**

```python
浮点数 3.14159265358979
定点数 = int(3.14159265358979 * 65536) = 205884
还原   = 205884 / 65536 = 3.1415863037109375

误差 = 3.14159265358979 - 3.1415863037109375
     = 0.0000063498788525
     ≈ 0.000006  # 约 6 微
```

**误差来源2：乘除法的舍入**

```python
a = 1 / 3  # 浮点: 0.3333...
a_fixed = (65536 << 16) // 3 = 1431655765  # 定点表示

# 还原
a_float = 1431655765 / 65536 = 0.3333333134651184

误差 ≈ 0.00000002  # 约 2×10^-8
```

### 3.2 关键问题：误差会导致不同步吗？

**答案：不会！但有个前提。**

#### 前提：所有客户端用完全相同的算法

```python
# 客户端 A
def update_position(entity, dt_ms):
    entity.x += (entity.vx * dt_ms) // 1000  # 定点数运算

# 客户端 B（必须完全一样！）
def update_position(entity, dt_ms):
    entity.x += (entity.vx * dt_ms) // 1000  # 相同的整数运算
```

**关键点**：
1. 误差是**确定性的**——同一输入永远产生同一误差
2. 所有客户端产生**相同的误差**
3. 相同误差 = 状态一致 ✅

#### 对比浮点数的问题

```python
# 客户端 A (Intel x87 FPU)
entity.x += entity.vx * dt_ms / 1000  # 结果可能: 100.0000001

# 客户端 B (ARM NEON)  
entity.x += entity.vx * dt_ms / 1000  # 结果可能: 99.9999999

# 误差不同！状态分叉！
```

### 3.3 误差的量化分析

#### 16.16 格式的精度

```
最小可表示差异: 1 / 65536 ≈ 0.000015 (15微米级)
有效数字位数: 约 4-5 位小数
范围: -32768.9999... 到 32767.9999...
```

#### 对于游戏场景

| 场景 | 精度要求 | 16.16 定点数够用？ |
|------|----------|-------------------|
| 角色位置（像素） | 1 像素 = 1.0 | ✅ 绰绰有余 |
| 角色移动速度 | 1 像素/帧 | ✅ 绰绰有余 |
| 子弹轨迹 | 0.1 像素误差 | ✅ 足够 |
| 物理碰撞 | 0.01 像素 | ✅ 足够 |
| 高精度物理模拟 | 0.0001 像素 | ⚠️ 可能不够 |

### 3.4 误差累积问题

**担心**：误差会不会随着时间累积越来越大？

**分析**：

```python
# 每帧的误差
frame_error = 0.00001  # 极小

# 100 帧后的累积误差（最坏情况）
total_error = 0.00001 * 100 = 0.001  # 仍然很小

# 10000 帧后（约 5 分钟）
total_error = 0.00001 * 10000 = 0.1  # 约 0.1 像素
```

**结论**：
- 对于普通游戏，误差累积在可接受范围内
- 定期（如每秒）进行状态校验可防止累积

### 3.5 真实案例：误差的影响

```python
# 场景：两个角色碰撞检测

角色A位置: 定点数表示 100.1234
角色B位置: 定点数表示 200.5678

实际存储:
  A.x = 6569219 (100.1234 × 65536 ≈ 6569218.87 → 截断)
  B.x = 13147146 (200.5678 × 65536 ≈ 13147145.83 → 截断)

误差:
  A.x 实际表示: 6569219 / 65536 = 100.12342071...
  与原值差异: 0.00002071...

影响:
  - 碰撞检测阈值是 10 像素
  - 误差 0.00002 像素完全不影响判断
  - 所有客户端都是相同的 0.00002 误差
```

---

## 4. 实战：定点数在帧同步中的应用

### 4.1 实体位置表示

```python
@dataclass
class Entity:
    entity_id: int
    x: int = 0      # 定点数！不是浮点数！
    y: int = 0      # 定点数！
    vx: int = 0     # 速度也是定点数
    vy: int = 0
    
    FIXED_SCALE = 65536
    
    @classmethod
    def from_float(cls, entity_id: int, x: float, y: float):
        """从浮点数创建（仅在初始化时使用）"""
        return cls(
            entity_id=entity_id,
            x=int(x * cls.FIXED_SCALE),
            y=int(y * cls.FIXED_SCALE)
        )
    
    def to_float(self):
        """转换为浮点数（仅用于渲染/调试）"""
        return (self.x / self.FIXED_SCALE, self.y / self.FIXED_SCALE)
```

### 4.2 物理更新（完全使用整数）

```python
class PhysicsEngine:
    GRAVITY = 980 << 16      # 980 像素/秒²，定点数
    FRICTION = 58982         # 0.9 的定点数 (0.9 × 65536)
    MAX_VELOCITY = 1000 << 16
    
    def update(self, dt_ms: int):
        for entity in self.entities.values():
            # 应用重力：vy += GRAVITY * dt / 1000
            entity.vy += (self.GRAVITY * dt_ms) // 1000
            
            # 限制最大速度
            entity.vx = max(-self.MAX_VELOCITY, min(self.MAX_VELOCITY, entity.vx))
            entity.vy = max(-self.MAX_VELOCITY, min(self.MAX_VELOCITY, entity.vy))
            
            # 更新位置：x += vx * dt / 1000
            entity.x += (entity.vx * dt_ms) // 1000
            entity.y += (entity.vy * dt_ms) // 1000
            
            # 应用摩擦力：vx = vx * friction
            entity.vx = (entity.vx * self.FRICTION) >> 16
```

### 4.3 碰撞检测

```python
def check_collision(a: Entity, b: Entity) -> bool:
    """AABB 碰撞检测（定点数）"""
    # 所有比较都是整数运算
    return (a.x < b.x + b.width and
            a.x + a.width > b.x and
            a.y < b.y + b.height and
            a.y + a.height > b.y)

# 分离重叠
def resolve_collision(a: Entity, b: Entity):
    overlap_x = min(a.x + a.width - b.x, b.x + b.width - a.x)
    overlap_y = min(a.y + a.height - b.y, b.y + b.height - a.y)
    
    if overlap_x < overlap_y:
        # 沿 X 轴分离（整数运算）
        if a.x < b.x:
            a.x -= overlap_x // 2
            b.x += overlap_x // 2
        else:
            a.x += overlap_x // 2
            b.x -= overlap_x // 2
    else:
        # 沿 Y 轴分离
        if a.y < b.y:
            a.y -= overlap_y // 2
            b.y += overlap_y // 2
        else:
            a.y += overlap_y // 2
            b.y -= overlap_y // 2
```

### 4.4 状态哈希校验

```python
import hashlib
import json

def compute_state_hash(entities: List[Entity]) -> str:
    """计算状态的确定性哈希"""
    # 按 ID 排序，保证顺序一致
    sorted_entities = sorted(entities, key=lambda e: e.entity_id)
    
    # 序列化（注意：用整数，不用浮点数）
    state = {
        'entities': [
            {
                'id': e.entity_id,
                'x': e.x,    # 直接用定点数整数
                'y': e.y,
                'vx': e.vx,
                'vy': e.vy
            }
            for e in sorted_entities
        ]
    }
    
    # JSON 序列化
    state_json = json.dumps(state, sort_keys=True, separators=(',', ':'))
    
    return hashlib.md5(state_json.encode()).hexdigest()

# 每隔 N 帧校验一次
if frame % 60 == 0:
    local_hash = compute_state_hash(entities)
    # 发送给服务器或其他客户端比对
```

---

## 5. 常见问题解答

### Q1：误差会导致"漂移"吗？

**A**：不会跨设备漂移。所有设备有相同的误差，所以状态仍然一致。

```
设备 A: 位置 100.1234（误差 0.00002）
设备 B: 位置 100.1234（误差 0.00002）
两者一致！✅
```

### Q2：如果需要更高精度怎么办？

**A**：使用更高位数的定点数：

| 格式 | 精度 | 范围 |
|------|------|------|
| 16.16 | 0.000015 | ±32768 |
| 24.8 | 0.0039 | ±8388608 |
| 8.24 | 0.00000006 | ±256 |
| 32.32（64位）| 0.0000000002 | ±2×10^9 |

```python
# 24.8 格式（更大范围，稍低精度）
FIXED_SHIFT = 8
FIXED_SCALE = 256

# 8.24 格式（更小范围，更高精度）
FIXED_SHIFT = 24
FIXED_SCALE = 16777216
```

### Q3：三角函数怎么办？

**A**：使用查表法：

```python
import math

# 预计算正弦表（0-359 度）
SIN_TABLE = [int(math.sin(math.radians(i)) * 65536) for i in range(360)]

def sin_fixed(angle_degrees: int) -> int:
    """定点数正弦（角度 0-359）"""
    angle = angle_degrees % 360
    return SIN_TABLE[angle]

def cos_fixed(angle_degrees: int) -> int:
    """定点数余弦"""
    return sin_fixed(angle_degrees + 90)

# 使用
angle = 45
vx = (speed * cos_fixed(angle)) >> 16
vy = (speed * sin_fixed(angle)) >> 16
```

### Q4：开根号怎么办？

**A**：使用整数平方根算法：

```python
def isqrt(n: int) -> int:
    """整数平方根（牛顿法）"""
    if n < 0:
        return 0
    if n == 0:
        return 0
    
    x = n
    y = (x + 1) // 2
    while y < x:
        x = y
        y = (x + n // x) // 2
    return x

# 距离计算
def distance(x1, y1, x2, y2):
    dx = x2 - x1
    dy = y2 - y1
    dist_sq = (dx * dx + dy * dy) >> 16  # 定点数调整
    return isqrt(dist_sq)
```

### Q5：为什么不用 decimal 模块？

**A**：Python 的 decimal 模块确实精确，但：

1. **性能差**：比原生整数慢 10-100 倍
2. **序列化复杂**：需要特殊处理
3. **其他语言不兼容**：C++/Java 没有相同的 decimal

定点数用原生整数，跨语言兼容，性能最优。

### Q6：渲染时怎么办？

**A**：只在最后渲染时转换为浮点数：

```python
# 游戏逻辑（定点数）
entity.x = 6569219  # 定点数

# 渲染（浮点数）
screen_x, screen_y = entity.to_float()  # 转换一次
draw_sprite(screen_x, screen_y)

# 或者直接用整数像素
screen_x, screen_y = entity.to_int()  # 丢弃小数部分
draw_sprite(screen_x, screen_y)
```

---

## 总结

| 问题 | 答案 |
|------|------|
| **为什么不用浮点数？** | 不同设备结果不同，导致状态分叉 |
| **定点数有误差吗？** | 有，但误差是确定性的，所有设备相同 |
| **误差会影响帧同步？** | 不会，相同误差 = 状态一致 |
| **精度够用吗？** | 16.16 格式对大多数游戏足够 |
| **如何处理三角函数？** | 预计算查表 |
| **如何处理开根号？** | 整数平方根算法 |

**核心要点**：

> 定点数的价值不在于"无误差"，而在于"**所有设备有相同的误差**"。

这正是帧同步所需要的：**确定性 > 精确性**

---

## 参考资料

- [IEEE 754 浮点数标准](https://en.wikipedia.org/wiki/IEEE_754)
- [定点数算术 - 维基百科](https://en.wikipedia.org/wiki/Fixed-point_arithmetic)
- [DOOM 源码中的定点数实现](https://github.com/id-Software/DOOM/blob/master/linuxdoom-1.10/m_fixed.c)
- [游戏编程精粹 - 定点数数学](https://www.satori.org/game-programming-gems/)
